#!/usr/bin/env python3
"""
solve_laplace.py

Author: Dr. Denys Dutykh (Khalifa University of Science and Technology, Abu Dhabi, UAE)
Date: 2025-05-13

Solves the Laplace equation ∇²Φ = 0 in a 2D wave tank domain with:
  • Periodic BC in x (at x=0 and x=L)
  • Homogeneous Neumann BC at bottom (∂Φ/∂y = 0 at y = -h0)
  • Dirichlet BC on free surface (Φ = φ(x) at y = η(x))
Plots the solution field.

Requires:
  • mesh.xdmf : the domain mesh generated by mesh_domain.py
  • data/data.csv : CSV containing x,η,φ,L,h0

Usage:
    python solve_laplace.py --mesh mesh/mesh.xdmf --data data/data.csv --degree 2 --output solution/solution.xdmf
"""

import os
os.environ["QT_QPA_PLATFORM"] = "xcb"

import numpy as np
from scipy.interpolate import CubicSpline
from matplotlib.tri import Triangulation
from fenics import (UserExpression, Function, FunctionSpace, VectorFunctionSpace,
    TrialFunction, TestFunction, DirichletBC, Constant, dx, grad, project,
    assemble, solve, XDMFFile, Mesh, MeshFunction, near, inner, SubDomain, cells)
import argparse
import matplotlib.pyplot as plt

def read_data(path):
    raw = np.loadtxt(path, delimiter=',', skiprows=1)
    x = raw[:,0]
    eta = raw[:,1]
    phi = raw[:,2]
    L = float(raw[0,3])
    h0 = float(raw[0,4])
    # Enforce periodicity at x=0 and x=L for eta and phi
    idx_sort = np.argsort(x)
    x = x[idx_sort]
    eta = eta[idx_sort]
    phi = phi[idx_sort]
    # Build splines for extrapolation if needed
    eta_spline = CubicSpline(x, eta, extrapolate=True)
    phi_spline = CubicSpline(x, phi, extrapolate=True)
    # Ensure x=0 and x=L are present
    if x[0] > 1e-12:
        x = np.insert(x, 0, 0.0)
        eta = np.insert(eta, 0, eta_spline(0.0))
        phi = np.insert(phi, 0, phi_spline(0.0))
    if abs(x[-1] - L) > 1e-12:
        x = np.append(x, L)
        eta = np.append(eta, eta_spline(L))
        phi = np.append(phi, phi_spline(L))
    # Enforce periodicity
    eta[0] = eta[-1] = 0.5 * (eta[0] + eta[-1])
    phi[0] = phi[-1] = 0.5 * (phi[0] + phi[-1])
    return x, eta, phi, L, h0

class PeriodicBoundary(SubDomain):
    def __init__(self, L, tol=1e-8):
        super().__init__()
        self.L = L
        self.tol = tol
    def inside(self, x, on_boundary):
        return on_boundary and near(x[0], 0.0, self.tol)
    def map(self, x, y):
        if near(x[0], self.L, self.tol):
            y[0] = x[0] - self.L
            y[1] = x[1]
            if len(x) > 2:  # Handle 3D case even though we're in 2D
                y[2] = x[2]
        else:
            y[0] = x[0]
            y[1] = x[1]
            if len(x) > 2:  # Handle 3D case even though we're in 2D
                y[2] = x[2]

class FreeSurface(SubDomain):
    def __init__(self, eta_spline, tol=1e-3):
        super().__init__()
        self.eta = eta_spline
        self.tol = tol
    def inside(self, x, on_boundary):
        return on_boundary and near(x[1], float(self.eta(x[0])), self.tol)

class PhiExpression(UserExpression):
    def __init__(self, phi_spline, **kwargs):
        super().__init__(**kwargs)
        self.spline = phi_spline
    def eval(self, values, x):
        values[0] = float(self.spline(x[0]))
    def value_shape(self):
        return ()

def plot_scalar(field, mesh, title='Field'):  # pragma: no cover
    """Plot a scalar field defined on mesh vertices."""
    coords = mesh.coordinates()
    values = field.compute_vertex_values(mesh)
    # Extract triangle connectivity
    cells_array = []
    for cell in cells(mesh):
        vert = cell.entities(0)
        cells_array.append([vert[0], vert[1], vert[2]])
    cells_array = np.array(cells_array, dtype=np.int32)
    tri = Triangulation(coords[:,0], coords[:,1], cells_array)
    plt.figure(figsize=(6,5))
    tpc = plt.tricontourf(tri, values, 50)
    cbar = plt.colorbar(tpc, label=title)
    # Add min/max info for uy_minus_vx plots
    if 'u_y - v_x' in title or 'uy_minus_vx' in title or '|.|' in title:
        minval = np.min(values)
        maxval = np.max(values)
        cbar.ax.set_ylabel(f'{title}\n[min={minval:.2e}, max={maxval:.2e}]', rotation=270, labelpad=20)
    plt.xlabel('x')
    plt.ylabel('y')
    plt.title(title)
    plt.gca().set_aspect('equal')
    plt.tight_layout()
    plt.show()

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--mesh',    required=True,
                        help='Input XDMF mesh file')
    parser.add_argument('--data',    required=True,
                        help='CSV file with x,eta,phi,L,h0')
    parser.add_argument('--degree',  type=int, default=2,
                        help='Polynomial degree of finite elements')
    parser.add_argument('--output',  default='solution/solution.xdmf',
                        help='Filename for soln (XDMF)')
    args = parser.parse_args()

    # Read and interpolate boundary data
    x, eta, phi, L, h0 = read_data(args.data)
    eta_spline = CubicSpline(x, eta, extrapolate=True)
    phi_spline = CubicSpline(x, phi, extrapolate=True)

    # Load mesh
    mesh = Mesh()
    with XDMFFile(args.mesh) as infile:
        infile.read(mesh)

    # Mark free surface for Dirichlet BC
    boundaries = MeshFunction('size_t', mesh, mesh.topology().dim()-1, 0)
    free = FreeSurface(eta_spline)
    free.mark(boundaries, 1)

    # Function space with periodic BC in x
    V = FunctionSpace(mesh, 'Lagrange', args.degree,
                      constrained_domain=PeriodicBoundary(L))

    # Apply Dirichlet BC on free surface
    phi_expr = PhiExpression(phi_spline, degree=args.degree)
    bc = DirichletBC(V, phi_expr, boundaries, 1)

    # Solve Laplace equation
    u = TrialFunction(V)
    v = TestFunction(V)
    a = inner(grad(u), grad(v)) * dx
    Lf = Constant(0.0) * v * dx
    sol = Function(V)
    solve(a == Lf, sol, bc)

    # Ensure output directory exists
    sol_dir = os.path.dirname(args.output) or 'solution'
    os.makedirs(sol_dir, exist_ok=True)
    with XDMFFile(args.output) as outfile:
        outfile.write(sol)
    print(f'Solution written to {args.output}')

    # Plot potential
    plot_scalar(sol, mesh, title='Φ(x,y)')

    # Compute velocity components
    W = VectorFunctionSpace(mesh, 'Lagrange', args.degree)
    grad_sol = project(grad(sol), W)
    components = grad_sol.split()
    u_comp = components[0]
    v_comp = components[1]
    u_comp.set_allow_extrapolation(True)
    v_comp.set_allow_extrapolation(True)

    # Compute gradients of u and v (each is a vector field)
    grad_u = project(grad(u_comp), W)
    grad_v = project(grad(v_comp), W)

    # Save gradients to XDMF
    grad_u_file = os.path.join(sol_dir, 'grad_u.xdmf')
    grad_v_file = os.path.join(sol_dir, 'grad_v.xdmf')
    with XDMFFile(grad_u_file) as fgu:
        fgu.write(grad_u)
    with XDMFFile(grad_v_file) as fgv:
        fgv.write(grad_v)
    print(f'Gradient of u saved to {grad_u_file}')
    print(f'Gradient of v saved to {grad_v_file}')

    # Compute u_y - v_x
    # grad_u: [∂u/∂x, ∂u/∂y], grad_v: [∂v/∂x, ∂v/∂y]
    # Extract components
    u_y = project(grad_u[1], FunctionSpace(mesh, 'Lagrange', args.degree))
    v_x = project(grad_v[0], FunctionSpace(mesh, 'Lagrange', args.degree))
    uy_minus_vx = project(u_y - v_x, FunctionSpace(mesh, 'Lagrange', args.degree))

    # Plot u_y - v_x and print its norms
    max_norm = np.max(np.abs(uy_minus_vx.compute_vertex_values(mesh)))
    l2_norm = np.sqrt(assemble(uy_minus_vx**2 * dx))
    print(f'Maximum |u_y - v_x| over the domain: {max_norm:.3e}')
    print(f'L2 norm of u_y - v_x over the domain: {l2_norm:.3e}')
    plot_scalar(uy_minus_vx, mesh, title=f"u_y - v_x (max |.|={max_norm:.2e})")

    # Plot horizontal and vertical velocities
    # plot_scalar(u_comp, mesh, title='u = ∂Φ/∂x (horizontal velocity)')
    # plot_scalar(v_comp, mesh, title='v = ∂Φ/∂y (vertical velocity)')

    # New: extract velocities on free surface and plot & save
    # Evaluate u and v at free-surface points
    x_pts = x   # original x data from CSV
    u_vals = np.array([u_comp([pt, eta_spline(pt), 0.0]) for pt in x_pts])
    v_vals = np.array([v_comp([pt, eta_spline(pt), 0.0]) for pt in x_pts])

    # # Plot u and v along free surface
    # fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8, 6), sharex=True)
    # ax1.plot(x_pts, u_vals, 'b-')
    # ax1.set_ylabel('u (x, η(x))')
    # ax1.set_title('Horizontal velocity on free surface')
    # ax2.plot(x_pts, v_vals, 'r-')
    # ax2.set_xlabel('x')
    # ax2.set_ylabel('v (x, η(x))')
    # ax2.set_title('Vertical velocity on free surface')
    # plt.tight_layout()
    # plt.show()

    # Save free surface velocities to CSV
    sol_dir = os.path.dirname(args.output) or 'solution'
    u_csv = os.path.join(sol_dir, 'u_free_surface.csv')
    v_csv = os.path.join(sol_dir, 'v_free_surface.csv')
    np.savetxt(u_csv, np.column_stack((x_pts, u_vals)),
               delimiter=',', header='x,u', comments='')
    np.savetxt(v_csv, np.column_stack((x_pts, v_vals)),
               delimiter=',', header='x,v', comments='')
    print(f'Free-surface velocities saved to {u_csv} and {v_csv}')

if __name__ == '__main__':
    main()
