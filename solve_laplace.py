#!/usr/bin/env python3
"""
solve_laplace.py

Solves the Laplace equation ∇²Φ = 0 in a 2D wave tank domain with:
  • Periodic BC in x (at x=0 and x=L)
  • Homogeneous Neumann BC at bottom (∂Φ/∂y = 0 at y = -h0)
  • Dirichlet BC on free surface (Φ = φ(x) at y = η(x))
Plots the solution field.

Requires:
  • mesh.xdmf : the domain mesh generated by mesh_domain.py
  • data/data.csv : CSV containing x,η,φ,L,h0

Usage:
    python solve_laplace.py --mesh mesh.xdmf --data data/data.csv --degree 2 --output solution.xdmf
"""

import numpy as np
from scipy.interpolate import CubicSpline
from fenics import *
import meshio
import argparse
import matplotlib.pyplot as plt

def read_data(path):
    raw = np.loadtxt(path, delimiter=',', skiprows=1)
    x = raw[:,0]
    eta = raw[:,1]
    phi = raw[:,2]
    L = float(raw[0,3])
    h0 = float(raw[0,4])
    return x, eta, phi, L, h0

class PeriodicBoundary(SubDomain):
    def __init__(self, L, tol=1e-8):
        super().__init__()
        self.L = L
        self.tol = tol
    def inside(self, x, on_boundary):
        return on_boundary and near(x[0], 0.0, self.tol)
    def map(self, x, y):
        if near(x[0], self.L, self.tol):
            y[0] = x[0] - self.L
            y[1] = x[1]
        else:
            y[0] = x[0]
            y[1] = x[1]

class FreeSurface(SubDomain):
    def __init__(self, eta_spline, tol=1e-3):
        super().__init__()
        self.eta = eta_spline
        self.tol = tol
    def inside(self, x, on_boundary):
        return on_boundary and near(x[1], float(self.eta(x[0])), self.tol)

class PhiExpression(UserExpression):
    def __init__(self, phi_spline, **kwargs):
        super().__init__(**kwargs)
        self.spline = phi_spline
    def eval(self, values, x):
        values[0] = float(self.spline(x[0]))
    def value_shape(self):
        return ()

def plot_solution(sol, mesh, title='Φ(x,y)'):  # pragma: no cover
    # Extract vertex coordinates and solution values
    coords = mesh.coordinates()
    values = sol.compute_vertex_values(mesh)

    # Create a Triangulation
    from matplotlib.tri import Triangulation
    tri = Triangulation(coords[:, 0], coords[:, 1], mesh.cells()["triangle"])
    plt.figure(figsize=(6,5))
    tpc = plt.tricontourf(tri, values, 50)
    plt.colorbar(tpc, label='Φ')
    plt.xlabel('x')
    plt.ylabel('y')
    plt.title(title)
    plt.gca().set_aspect('equal')
    plt.tight_layout()
    plt.show()

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--mesh',    required=True,
                        help='Input XDMF mesh file')
    parser.add_argument('--data',    required=True,
                        help='CSV file with x,eta,phi,L,h0')
    parser.add_argument('--degree',  type=int, default=2,
                        help='Polynomial degree of finite elements')
    parser.add_argument('--output',  default='solution.xdmf',
                        help='Filename for soln (XDMF)')
    args = parser.parse_args()

    x, eta, phi, L, h0 = read_data(args.data)
    eta_spline = CubicSpline(x, eta, extrapolate=True)
    phi_spline = CubicSpline(x, phi, extrapolate=True)

    mesh = Mesh()
    with XDMFFile(args.mesh) as infile:
        infile.read(mesh)

    boundaries = MeshFunction('size_t', mesh, mesh.topology().dim()-1, 0)
    free = FreeSurface(eta_spline)
    free.mark(boundaries, 1)

    V = FunctionSpace(mesh, 'Lagrange', args.degree,
                      constrained_domain=PeriodicBoundary(L))

    phi_expr = PhiExpression(phi_spline, degree=args.degree)
    bc = DirichletBC(V, phi_expr, boundaries, 1)

    u = TrialFunction(V)
    v = TestFunction(V)
    a = inner(grad(u), grad(v)) * dx
    Lf = Constant(0.0) * v * dx

    sol = Function(V)
    solve(a == Lf, sol, bc)

    with XDMFFile(args.output) as outfile:
        outfile.write(sol)
    print(f'Solution written to {args.output}')

    # Plot solution
    plot_solution(sol, mesh)

if __name__ == '__main__':
    main()
