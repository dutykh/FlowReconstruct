#!/usr/bin/env python3
"""
solve_laplace.py

Author: Dr. Denys Dutykh (Khalifa University of Science and Technology, Abu Dhabi, UAE)
Date: 2025-05-13

Solves the Laplace equation ∇²Φ = 0 in a 2D wave tank domain with:
  • Periodic BC in x (at x=0 and x=L)
  • Homogeneous Neumann BC at bottom (∂Φ/∂y = 0 at y = -h0)
  • Dirichlet BC on free surface (Φ = φ(x) at y = η(x))
Plots the solution field.

Requires:
  • mesh.xdmf : the domain mesh generated by mesh_domain.py
  • data/data.csv : CSV containing x,η,φ,L,h0

Usage:
    python solve_laplace.py --mesh mesh/mesh.xdmf --data data/data.csv --degree 2 --output solution/solution.xdmf
"""

import os
os.environ["QT_QPA_PLATFORM"] = "xcb"

import numpy as np
from scipy.interpolate import CubicSpline
from fenics import *
import meshio
import argparse
import matplotlib.pyplot as plt

def read_data(path):
    raw = np.loadtxt(path, delimiter=',', skiprows=1)
    x = raw[:,0]
    eta = raw[:,1]
    phi = raw[:,2]
    L = float(raw[0,3])
    h0 = float(raw[0,4])
    return x, eta, phi, L, h0

class PeriodicBoundary(SubDomain):
    def __init__(self, L, tol=1e-8):
        super().__init__()
        self.L = L
        self.tol = tol
    def inside(self, x, on_boundary):
        return on_boundary and near(x[0], 0.0, self.tol)
    def map(self, x, y):
        if near(x[0], self.L, self.tol):
            y[0] = x[0] - self.L
            y[1] = x[1]
            if len(x) > 2:  # Handle 3D case even though we're in 2D
                y[2] = x[2]
        else:
            y[0] = x[0]
            y[1] = x[1]
            if len(x) > 2:  # Handle 3D case even though we're in 2D
                y[2] = x[2]

class FreeSurface(SubDomain):
    def __init__(self, eta_spline, tol=1e-3):
        super().__init__()
        self.eta = eta_spline
        self.tol = tol
    def inside(self, x, on_boundary):
        return on_boundary and near(x[1], float(self.eta(x[0])), self.tol)

class PhiExpression(UserExpression):
    def __init__(self, phi_spline, **kwargs):
        super().__init__(**kwargs)
        self.spline = phi_spline
    def eval(self, values, x):
        values[0] = float(self.spline(x[0]))
    def value_shape(self):
        return ()

def plot_scalar(field, mesh, title='Field'):  # pragma: no cover
    """Plot a scalar field defined on mesh vertices."""
    from matplotlib.tri import Triangulation
    coords = mesh.coordinates()
    values = field.compute_vertex_values(mesh)
    # Extract triangle connectivity
    cells_array = []
    for cell in cells(mesh):
        vert = cell.entities(0)
        cells_array.append([vert[0], vert[1], vert[2]])
    tri = Triangulation(coords[:,0], coords[:,1], np.array(cells_array))
    plt.figure(figsize=(6,5))
    tpc = plt.tricontourf(tri, values, 50)
    plt.colorbar(tpc, label=title)
    plt.xlabel('x')
    plt.ylabel('y')
    plt.title(title)
    plt.gca().set_aspect('equal')
    plt.tight_layout()
    plt.show()

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--mesh',    required=True,
                        help='Input XDMF mesh file')
    parser.add_argument('--data',    required=True,
                        help='CSV file with x,eta,phi,L,h0')
    parser.add_argument('--degree',  type=int, default=2,
                        help='Polynomial degree of finite elements')
    parser.add_argument('--output',  default='solution/solution.xdmf',
                        help='Filename for soln (XDMF)')
    args = parser.parse_args()

    # Read and interpolate boundary data
    x, eta, phi, L, h0 = read_data(args.data)
    eta_spline = CubicSpline(x, eta, extrapolate=True)
    phi_spline = CubicSpline(x, phi, extrapolate=True)

    # Load mesh
    mesh = Mesh()
    with XDMFFile(args.mesh) as infile:
        infile.read(mesh)

    # Mark free surface for Dirichlet BC
    boundaries = MeshFunction('size_t', mesh, mesh.topology().dim()-1, 0)
    free = FreeSurface(eta_spline)
    free.mark(boundaries, 1)

    # Function space with periodic BC in x
    V = FunctionSpace(mesh, 'Lagrange', args.degree,
                      constrained_domain=PeriodicBoundary(L))

    # Apply Dirichlet BC on free surface
    phi_expr = PhiExpression(phi_spline, degree=args.degree)
    bc = DirichletBC(V, phi_expr, boundaries, 1)

    # Solve Laplace equation
    u = TrialFunction(V)
    v = TestFunction(V)
    a = inner(grad(u), grad(v)) * dx
    Lf = Constant(0.0) * v * dx
    sol = Function(V)
    solve(a == Lf, sol, bc)

    # Ensure output directory exists
    sol_dir = os.path.dirname(args.output) or 'solution'
    os.makedirs(sol_dir, exist_ok=True)
    with XDMFFile(args.output) as outfile:
        outfile.write(sol)
    print(f'Solution written to {args.output}')

    # Plot potential
    plot_scalar(sol, mesh, title='Φ(x,y)')

    # Compute velocity components
    W = VectorFunctionSpace(mesh, 'Lagrange', args.degree)
    grad_sol = project(grad(sol), W)
    components = grad_sol.split()
    u_comp = components[0]
    v_comp = components[1]

    # Plot horizontal and vertical velocities
    plot_scalar(u_comp, mesh, title='u = ∂Φ/∂x (horizontal velocity)')
    plot_scalar(v_comp, mesh, title='v = ∂Φ/∂y (vertical velocity)')

if __name__ == '__main__':
    main()
